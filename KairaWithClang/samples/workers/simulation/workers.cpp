/* This file is automatically generated
   do not edit this file directly! */

#include "workers.h"
ca::ParameterInt param::LIMIT("LIMIT", "", ca::PARAMETER_MANDATORY);
ca::ParameterInt param::SIZE("SIZE", "", ca::PARAMETER_MANDATORY);
class Tokens_107  : public ca::Binding {
	public:
	Tokens_107() {};
	Tokens_107(const Tokens_107 &t) {
		if (t.token_1001 != NULL) {
			token_1001 = new ca::Token<int >(t.token_1001->value);
		} else {
			token_1001 = NULL;
		}
		if (t.token_1003 != NULL) {
			token_1003 = new ca::Token<int >(t.token_1003->value);
		} else {
			token_1003 = NULL;
		}
	}
	Tokens_107& operator=(const Tokens_107 &t) {
		if (this != &t) {
			if (t.token_1001 != NULL) {
				delete token_1001;
				token_1001 = new ca::Token<int >(t.token_1001->value);
			} else {
				token_1001 = NULL;
			}
			if (t.token_1003 != NULL) {
				delete token_1003;
				token_1003 = new ca::Token<int >(t.token_1003->value);
			} else {
				token_1003 = NULL;
			}
		}
		return *this;
	}
	~Tokens_107() {
		if (token_1001 != NULL) {
			delete token_1001;
		}
		if (token_1003 != NULL) {
			delete token_1003;
		}
	}
	ca::Binding* copy() {
		Tokens_107 *t = new Tokens_107(*this);
		return t;
	}
	ca::Token<int > *token_1001;
	ca::Token<int > *token_1003;
};
class Transition_107  : public ca::TransitionDef {
	public:
	Transition_107() : ca::TransitionDef(107, "divide", ca::TRANSITION_IMMEDIATE, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
};
static Transition_107 transition_107;

class Vars_108 {
	public:
	Vars_108(ca::Context &ctx,Job &job,ca::TokenList<int > &results) : ctx(ctx),job(job),results(results) {
	}
	ca::Context &ctx;
	Job &job;
	ca::TokenList<int > &results;
};
void transition_user_fn_108(ca::Context &ctx, Vars_108 &var);
class Tokens_108  : public ca::Binding {
	public:
	Tokens_108() {};
	Tokens_108(const Tokens_108 &t) {
		if (t.token_1009 != NULL) {
			token_1009 = new ca::Token<Job >(t.token_1009->value);
		} else {
			token_1009 = NULL;
		}
	}
	Tokens_108& operator=(const Tokens_108 &t) {
		if (this != &t) {
			if (t.token_1009 != NULL) {
				delete token_1009;
				token_1009 = new ca::Token<Job >(t.token_1009->value);
			} else {
				token_1009 = NULL;
			}
		}
		return *this;
	}
	~Tokens_108() {
		if (token_1009 != NULL) {
			delete token_1009;
		}
	}
	ca::Binding* copy() {
		Tokens_108 *t = new Tokens_108(*this);
		return t;
	}
	ca::Token<Job > *token_1009;
};
class Transition_108  : public ca::TransitionDef {
	public:
	Transition_108() : ca::TransitionDef(108, "compute", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
};
static Transition_108 transition_108;

class Vars_109 {
	public:
	Vars_109(ca::Context &ctx,ca::TokenList<int > &results) : ctx(ctx),results(results) {
	}
	ca::Context &ctx;
	ca::TokenList<int > &results;
};
void transition_user_fn_109(ca::Context &ctx, Vars_109 &var);
class Tokens_109  : public ca::Binding {
	public:
	Tokens_109() {};
	Tokens_109(const Tokens_109 &t) {
		if (t.token_1015 != NULL) {
			token_1015 = new ca::Token<int >(t.token_1015->value);
		} else {
			token_1015 = NULL;
		}
		tokens_1020 = t.tokens_1020;
	}
	Tokens_109& operator=(const Tokens_109 &t) {
		if (this != &t) {
			if (t.token_1015 != NULL) {
				delete token_1015;
				token_1015 = new ca::Token<int >(t.token_1015->value);
			} else {
				token_1015 = NULL;
			}
			tokens_1020 = t.tokens_1020;
		}
		return *this;
	}
	~Tokens_109() {
		if (token_1015 != NULL) {
			delete token_1015;
		}
	}
	ca::Binding* copy() {
		Tokens_109 *t = new Tokens_109(*this);
		return t;
	}
	ca::Token<int > *token_1015;
	ca::Place<int > tokens_1020;
};
class Transition_109  : public ca::TransitionDef {
	public:
	Transition_109() : ca::TransitionDef(109, "write result", ca::TRANSITION_NORMAL, 0) {
	}
	ca::FireResult full_fire(ca::ThreadBase *thread, ca::NetBase *net);
	ca::Binding* fire_phase1(ca::ThreadBase *thread, ca::NetBase *net);
	void fire_phase2(ca::ThreadBase *thread, ca::NetBase *net, ca::Binding *data);
	bool is_enable(ca::ThreadBase *thread, ca::NetBase *net);
};
static Transition_109 transition_109;

class Net_0  : public ca::Net {
	public:
	Net_0(ca::NetDef * def,ca::Thread * thread) : ca::Net(def, thread) {
	}
	ca::NetBase * copy() {
		Net_0 *net = new Net_0(*this);
		return net;
	}
	ca::Place<int > place_103;
	ca::Place<int > place_104;
	ca::Place<Job > place_105;
	ca::Place<int > place_106;
	void write_reports_content(ca::ThreadBase *thread, ca::Output &output) {
		output.child("place");
		output.set("id", 103);
		{
			ca::Token<int > *t = place_103.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_103.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 104);
		{
			ca::Token<int > *t = place_104.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_104.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 105);
		{
			ca::Token<Job > *t = place_105.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_105.begin());
			}
		}
		output.back();
		output.child("place");
		output.set("id", 106);
		{
			ca::Token<int > *t = place_106.begin();
			if (t) {
				do {
					output.child("token");
					output.set("value", ca::token_name(t->value));
					output.back();
					t = t->next;
				} while (t != place_106.begin());
			}
		}
		output.back();
	}
	void receive(ca::ThreadBase *__kaira__thread, int from_process, int place_pos, ca::Unpacker &unpacker) {
		switch(place_pos) {
		case 119:
		{
			ca::Token<Job > *token = new ca::Token<Job >();
			ca::unpack(unpacker, token->value);
			this->place_105.add_token(token);
			this->activate_transition_by_pos_id(1);
		}
		break;
		case 117:
		{
			ca::Token<int > *token = new ca::Token<int >();
			ca::unpack(unpacker, token->value);
			this->place_104.add_token(token);
			this->activate_transition_by_pos_id(2);
			this->activate_transition_by_pos_id(0);
		}
		break;
		case 118:
		{
			ca::Token<int > *token = new ca::Token<int >();
			ca::unpack(unpacker, token->value);
			this->place_106.add_token(token);
			this->activate_transition_by_pos_id(2);
		}
		break;
		}
	}
};
ca::NetBase * spawn_0(ca::ThreadBase *__kaira__thread, ca::NetDef *__kaira__def) {
	Net_0 *__kaira__net = new Net_0(__kaira__def, (ca::Thread*) __kaira__thread);
	ca::Context ctx(__kaira__thread, __kaira__net);
	int __kaira__pid = __kaira__thread->get_process_id();
	if (__kaira__pid == 0) {
		__kaira__net->place_103.add(0);
	}
	if (__kaira__pid == 0) {
		__kaira__net->place_104.add(ca::range(1, ctx.process_count()));
	}
	return __kaira__net;
}
ca::FireResult Transition_107::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return ca::NOT_ENABLED;
	if (__kaira__n->place_104.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=worker
	ca::Token < int > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	int &worker = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1001);
			__kaira__n->place_104.remove(__kaira__token_1003);
		}
		__kaira__n->activate_transition_by_pos_id(0);
		__kaira__n->place_103.add(start + param::SIZE());
		__kaira__n->activate_transition_by_pos_id(2);
		__kaira__n->activate_transition_by_pos_id(0);
		if (worker == __kaira__thread->get_process_id()) {
			__kaira__n->place_105.add(Job(start, start + param::SIZE()));
			__kaira__n->activate_transition_by_pos_id(1);
		} else {
			int __kaira__target = worker;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (Job(start, start + param::SIZE())));
				__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
			}
			delete __kaira__token_1001;
			delete __kaira__token_1003;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_107::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return NULL;
	if (__kaira__n->place_104.size() < 1) return NULL;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=worker
	ca::Token < int > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	int &worker = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return NULL;
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1001);
			__kaira__n->place_104.remove(__kaira__token_1003);
		}
		Tokens_107 *__kaira__tokens = new Tokens_107();
		__kaira__tokens->token_1001 = __kaira__token_1001;
		__kaira__tokens->token_1003 = __kaira__token_1003;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_107::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	Tokens_107 *__kaira__tokens = static_cast<Tokens_107*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1001 = __kaira__tokens->token_1001;
	ca::Token<int > *__kaira__token_1003 = __kaira__tokens->token_1003;
	int &start = __kaira__token_1001->value;
	int &worker = __kaira__token_1003->value;
	__kaira__n->activate_transition_by_pos_id(0);
	__kaira__n->place_103.add(start + param::SIZE());
	__kaira__n->activate_transition_by_pos_id(2);
	__kaira__n->activate_transition_by_pos_id(0);
	if (worker == __kaira__thread->get_process_id()) {
		__kaira__n->place_105.add(Job(start, start + param::SIZE()));
		__kaira__n->activate_transition_by_pos_id(1);
} else {
	int __kaira__target = worker;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (Job(start, start + param::SIZE())));
		__kaira__thread->send(__kaira__target, __kaira__n, 119, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_107::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return false;
	if (__kaira__n->place_104.size() < 1) return false;
	// Inscription id=112 uid=1001 expr=start
	ca::Token < int > *__kaira__token_1001;
	__kaira__token_1001 = __kaira__n->place_103.begin();
	int &start = __kaira__token_1001->value;
	// Inscription id=112 uid=1003 expr=worker
	ca::Token < int > *__kaira__token_1003;
	__kaira__token_1003 = __kaira__n->place_104.begin();
	int &worker = __kaira__token_1003->value;
	if (!(start < param::LIMIT())) {
		return false;
	}
	{
		return true;
	}
	return false;
}
ca::FireResult Transition_108::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		{
			__kaira__n->place_105.remove(__kaira__token_1009);
		}
		__kaira__n->activate_transition_by_pos_id(1);
		ca::TokenList<int > results; // Fresh variable
		Vars_108 __kaira__vars(ctx,job,results);
		transition_user_fn_108(ctx, __kaira__vars);
		if (0 == __kaira__thread->get_process_id()) {
			__kaira__n->place_106.overtake(results);
			__kaira__n->activate_transition_by_pos_id(2);
		} else {
			int __kaira__target = 0;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				results.pack_tokens(__kaira__packer);
				__kaira__thread->send(__kaira__target, __kaira__n, 118, (results).size(), __kaira__packer);
			}
			if (0 == __kaira__thread->get_process_id()) {
				__kaira__n->place_104.add(ctx.process_id());
				__kaira__n->activate_transition_by_pos_id(2);
				__kaira__n->activate_transition_by_pos_id(0);
		} else {
			int __kaira__target = 0;
				ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
				ca::pack(__kaira__packer, (ctx.process_id()));
				__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
			}
			delete __kaira__token_1009;
			return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_108::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return NULL;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		{
			__kaira__n->place_105.remove(__kaira__token_1009);
		}
		Tokens_108 *__kaira__tokens = new Tokens_108();
		__kaira__tokens->token_1009 = __kaira__token_1009;
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_108::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	Tokens_108 *__kaira__tokens = static_cast<Tokens_108*>(__kaira__binding);
	ca::Token<Job > *__kaira__token_1009 = __kaira__tokens->token_1009;
	Job &job = __kaira__token_1009->value;
	__kaira__n->activate_transition_by_pos_id(1);
	ca::TokenList<int > results; // Fresh variable
	Vars_108 __kaira__vars(ctx,job,results);
	transition_user_fn_108(ctx, __kaira__vars);
	if (0 == __kaira__thread->get_process_id()) {
		__kaira__n->place_106.overtake(results);
		__kaira__n->activate_transition_by_pos_id(2);
} else {
	int __kaira__target = 0;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		results.pack_tokens(__kaira__packer);
		__kaira__thread->send(__kaira__target, __kaira__n, 118, (results).size(), __kaira__packer);
	}
	if (0 == __kaira__thread->get_process_id()) {
		__kaira__n->place_104.add(ctx.process_id());
		__kaira__n->activate_transition_by_pos_id(2);
		__kaira__n->activate_transition_by_pos_id(0);
} else {
	int __kaira__target = 0;
		ca::Packer __kaira__packer(ca::PACKER_DEFAULT_SIZE, ca::RESERVED_PREFIX);
		ca::pack(__kaira__packer, (ctx.process_id()));
		__kaira__thread->send(__kaira__target, __kaira__n, 117, 1, __kaira__packer);
	}
	delete __kaira__binding;
}
bool Transition_108::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_105.size() < 1) return false;
	// Inscription id=113 uid=1009 expr=job
	ca::Token < Job > *__kaira__token_1009;
	__kaira__token_1009 = __kaira__n->place_105.begin();
	Job &job = __kaira__token_1009->value;
	{
		return true;
	}
	return false;
}
ca::FireResult Transition_109::full_fire(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return ca::NOT_ENABLED;
	// Inscription id=116 uid=1015 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1015->value) == (param::LIMIT()))) {
		return ca::NOT_ENABLED;
	}
	if (__kaira__token_1015->value != (param::LIMIT())) {
		return ca::NOT_ENABLED;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return ca::NOT_ENABLED;
		}
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1015);
		}
		__kaira__n->activate_transition_by_pos_id(2);
		ca::TokenList<int > results;
		__kaira__n->place_106.put_into(results);
		Vars_109 __kaira__vars(ctx,results);
		transition_user_fn_109(ctx, __kaira__vars);
		delete __kaira__token_1015;
		return ca::TRANSITION_FIRED;
	}
	return ca::NOT_ENABLED;
}
ca::Binding* Transition_109::fire_phase1(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return NULL;
	// Inscription id=116 uid=1015 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1015->value) == (param::LIMIT()))) {
		return NULL;
	}
	if (__kaira__token_1015->value != (param::LIMIT())) {
		return NULL;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return NULL;
		}
	}
	{
		{
			__kaira__n->place_103.remove(__kaira__token_1015);
		}
		Tokens_109 *__kaira__tokens = new Tokens_109();
		__kaira__tokens->token_1015 = __kaira__token_1015;
		__kaira__tokens->tokens_1020.overtake(__kaira__n->place_106);
		return __kaira__tokens;
	}
	return NULL;
}
void Transition_109::fire_phase2(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net, ca::Binding *__kaira__binding)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	Tokens_109 *__kaira__tokens = static_cast<Tokens_109*>(__kaira__binding);
	ca::Token<int > *__kaira__token_1015 = __kaira__tokens->token_1015;
	__kaira__n->activate_transition_by_pos_id(2);
	ca::TokenList<int > results;
	__kaira__tokens->tokens_1020.put_into(results);
	Vars_109 __kaira__vars(ctx,results);
	transition_user_fn_109(ctx, __kaira__vars);
	delete __kaira__binding;
}
bool Transition_109::is_enable(ca::ThreadBase *__kaira__thread, ca::NetBase *__kaira__net)
{
	ca::Context ctx(__kaira__thread, __kaira__net);
	Net_0 *__kaira__n = (Net_0*) __kaira__net;
	if (__kaira__n->place_103.size() < 1) return false;
	// Inscription id=116 uid=1015 expr=param::LIMIT()
	ca::Token < int > *__kaira__token_1015;
	__kaira__token_1015 = __kaira__n->place_103.begin();
	if (!((__kaira__token_1015->value) == (param::LIMIT()))) {
		return false;
	}
	if (__kaira__token_1015->value != (param::LIMIT())) {
		return false;
	}
	{
		size_t size = __kaira__n->place_104.size();
		if (!(size == ctx.process_count() - 1)) {
			return false;
		}
	}
	{
		return true;
	}
	return false;
}
int main(int argc, char **argv)
{
	ca::project_description("<project library-octave=\"False\" library-rpc=\"False\" target_env=\"C++\"><configuration><parameter default=\"120\" description=\"\" name=\"LIMIT\" policy=\"mandatory\" type=\"int\" /><parameter default=\"10\" description=\"\" name=\"SIZE\" policy=\"mandatory\" type=\"int\" /><build-option name=\"LIBS\" /><build-option name=\"CFLAGS\">-O2</build-option><head-code>\nstruct Job {\n\tJob() {};\n\tJob(int start, int end) : start(start), end(end) {}\n\tint start;\n\tint end;\n\n\tvoid pack(ca::Packer &amp;p) const {\n\t\tp &lt;&lt; start &lt;&lt; end;\n\t}\n\n\tvoid unpack(ca::Unpacker &amp;p) {\n\t\tp &gt;&gt; start &gt;&gt; end;\n\t}\n\t\n\tstd::string token_name() const {\n\t\tstd::stringstream s;\n\t\ts &lt;&lt; \"Job [\" &lt;&lt; start &lt;&lt; \",\" &lt;&lt; end &lt;&lt; \")\";\n\t\treturn s.str();\n\t}\n};\n\nJob jj;\n\n\n\n\n</head-code></configuration><net id=\"0\" name=\"Main\"><place id=\"103\" label-x=\"38\" label-y=\"255\" name=\"counter\" radius=\"20\" sx=\"4\" sy=\"0\" x=\"38\" y=\"255\"><place-type x=\"65\" y=\"271\">int</place-type><init x=\"52\" y=\"222\">[0]</init><trace trace-tokens=\"False\" /></place><place id=\"104\" label-x=\"186\" label-y=\"252\" name=\"ready\" radius=\"20\" sx=\"0\" sy=\"0\" x=\"186\" y=\"252\"><place-type x=\"203\" y=\"269\">int</place-type><init x=\"203\" y=\"227\">ca::range(1, ctx.process_count())</init><trace trace-tokens=\"False\" /></place><place id=\"105\" label-x=\"415\" label-y=\"165\" name=\"\" radius=\"22\" sx=\"0\" sy=\"0\" x=\"415\" y=\"165\"><place-type x=\"432\" y=\"182\">Job</place-type><init x=\"432\" y=\"135\" /><trace trace-tokens=\"False\" /></place><place id=\"106\" label-x=\"270\" label-y=\"360\" name=\"results\" radius=\"20\" sx=\"0\" sy=\"0\" x=\"270\" y=\"360\"><place-type x=\"287\" y=\"377\">int</place-type><init x=\"287\" y=\"330\" /><trace trace-tokens=\"False\" /></place><transition clock=\"False\" collective=\"False\" id=\"107\" label-x=\"258\" label-y=\"116\" name=\"divide\" priority=\"\" sx=\"90\" sy=\"35\" x=\"192\" y=\"90\"><guard x=\"192\" y=\"70\">start &lt; param::LIMIT()</guard><trace>fire</trace><verif-occurrence binding=\"False\" process=\"True\" /></transition><transition clock=\"False\" collective=\"False\" id=\"108\" label-x=\"431\" label-y=\"262\" name=\"compute\" priority=\"\" sx=\"70\" sy=\"35\" x=\"380\" y=\"235\"><guard x=\"380\" y=\"215\" /><code>\tint vvuvu;\n\tfor (vvuvu=var.job.start; vvuvu &lt; var.job.end; vvuvu++) {\n\t\n\t\tif (vvuvu &lt; 2) continue;\n\t\tint s;\n\t\ts = 2;\n\t\twhile( (s*s) &lt;= vvuvu) {\n\t\t\tif ((vvuvu % s) == 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\ts++;\n\t\t\t\n\t\t}\n\t\tif (s*s &gt; vvuvu) {\n\t\t\tvar.results.add(vvuvu);\n\t\t}\n\n\t}\n\t\n\t\n\t\n\t\t \n</code><trace>fire</trace><verif-occurrence binding=\"True\" process=\"False\" /></transition><transition clock=\"False\" collective=\"False\" id=\"109\" label-x=\"117\" label-y=\"361\" name=\"write result\" priority=\"\" sx=\"70\" sy=\"35\" x=\"82\" y=\"343\"><guard x=\"82\" y=\"323\" /><code>\tca::Token&lt;int&gt; *t;\n\t\t\n\tfor (t = var.results.begin(); t != NULL; t = var.results.next(t)) {\n\t\tprintf(\"%i\\n\", t-&gt;value);\n\t}\n\tctx.quit();\n\t\n</code><trace>fire</trace><verif-occurrence binding=\"False\" process=\"True\" /></transition><edge from_item=\"103\" id=\"110\" to_item=\"107\"><inscription x=\"132.0\" y=\"192.0\">start</inscription></edge><edge from_item=\"107\" id=\"111\" to_item=\"103\"><inscription x=\"51.0\" y=\"88.0\">start + param::SIZE()</inscription><point x=\"37\" y=\"107\" /></edge><edge from_item=\"104\" id=\"112\" to_item=\"107\"><inscription x=\"217.0\" y=\"180.0\">worker</inscription></edge><edge from_item=\"105\" id=\"113\" to_item=\"108\"><inscription x=\"424.0\" y=\"206.0\">job</inscription></edge><edge from_item=\"103\" id=\"114\" to_item=\"109\"><inscription x=\"0.0\" y=\"305.0\">param::LIMIT()</inscription></edge><edge from_item=\"104\" id=\"115\" to_item=\"109\"><inscription x=\"159.0\" y=\"301.0\">[guard(size == ctx.process_count() - 1 ) ]</inscription></edge><edge from_item=\"106\" id=\"116\" to_item=\"109\"><inscription x=\"173.0\" y=\"345.0\">[bulk] results</inscription></edge><edge from_item=\"108\" id=\"117\" to_item=\"104\"><inscription x=\"260.0\" y=\"258.0\">ctx.process_id()@0</inscription></edge><edge from_item=\"108\" id=\"118\" to_item=\"106\"><inscription x=\"316.0\" y=\"344.0\">[bulk] results@0</inscription><point x=\"415\" y=\"360\" /></edge><edge from_item=\"107\" id=\"119\" to_item=\"105\"><inscription x=\"313.0\" y=\"88.0\">Job(start, start + param::SIZE())@worker</inscription><point x=\"415\" y=\"107\" /></edge></net></project>");
	std::vector<ca::Parameter*> parameters;
	parameters.push_back(&param::LIMIT);
	parameters.push_back(&param::SIZE);

	ca::init(argc, argv, parameters, false);

	ca::NetDef *def_0 = new ca::NetDef(0, 0, spawn_0);
	def_0->register_transition(&transition_107);
	def_0->register_transition(&transition_108);
	def_0->register_transition(&transition_109);
	ca::NetDef *defs[] = {def_0};
	ca::setup(1, defs, true);
	ca::spawn_net(0);
	ca::main();
	return 0;
}
#line 1 "*108/function"
void transition_user_fn_108(ca::Context &ctx, Vars_108 &var)
{
	int vvuvu;
	for (vvuvu=var.job.start; vvuvu < var.job.end; vvuvu++) {
	
		if (vvuvu < 2) continue;
		int s;
		s = 2;
		while( (s*s) <= vvuvu) {
			if ((vvuvu % s) == 0) {
				break;
			}
			s++;
			
		}
		if (s*s > vvuvu) {
			var.results.add(vvuvu);
		}

	}
	
	
	
		 
}
#line 1 "*109/function"
void transition_user_fn_109(ca::Context &ctx, Vars_109 &var)
{
	ca::Token<int> *t;
		
	for (t = var.results.begin(); t != NULL; t = var.results.next(t)) {
		printf("%i\n", t->value);
	}
	ctx.quit();
	
}
